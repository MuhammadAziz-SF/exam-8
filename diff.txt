```diff
diff --git a/.dockerignore b/.dockerignore
new file mode 100644
index 0000000..631452c
--- /dev/null
+++ b/.dockerignore
@@ -0,0 +1,17 @@
+.git
+.gitignore
+.dockerignore
+node_modules
+npm-debug.log
+README.md
+Dockerfile
+docker-compose.yml
+docker-compose.ci.yml
+.env
+.env.*
+dist
+test
+coverage
+.vscode
+.idea
diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
new file mode 100644
index 0000000..732808c
--- /dev/null
+++ b/.github/workflows/main.yml
@@ -0,0 +1,102 @@
+name: CI/CD Pipeline
+
+on:
+  push:
+    branches: [ "main" ]
+  pull_request:
+    branches: [ "main" ]
+
+jobs:
+  lint-and-unit-test:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout code
+        uses: actions/checkout@v4
+
+      - name: Set up Node.js
+        uses: actions/setup-node@v4
+        with:
+          node-version: '20'
+          cache: 'npm'
+
+      - name: Install dependencies
+        run: npm ci
+
+      - name: Run linter
+        run: npm run lint
+
+      - name: Run unit tests
+        run: npm test
+
+  e2e-test:
+    runs-on: ubuntu-latest
+    needs: lint-and-unit-test
+    steps:
+      - name: Checkout code
+        uses: actions/checkout@v4
+
+      - name: Create .env.test file
+        run: |
+          echo "PORT=3000" > .env.test
+          echo "PG_HOST=db" >> .env.test
+          echo "PG_PORT=5432" >> .env.test
+          echo "PG_USER=testuser" >> .env.test
+          echo "PG_PASS=testpass" >> .env.test
+          echo "PG_DB=testdb" >> .env.test
+          echo "PG_DB_TEST=testdb" >> .env.test
+          echo "ACCESS_TOKEN_KEY=some-secret-key-for-testing" >> .env.test
+          echo "ACCESS_TOKEN_TIME=15m" >> .env.test
+          echo "REFRESH_TOKEN_KEY=another-secret-key-for-testing" >> .env.test
+          echo "REFRESH_TOKEN_TIME=7d" >> .env.test
+          echo "DB_URL=dummy" >> .env.test
+          echo "SMTP_HOST=dummy" >> .env.test
+          echo "SMTP_PORT=dummy" >> .env.test
+          echo "SMTP_USER=dummy" >> .env.test
+          echo "SMTP_PASS=dummy" >> .env.test
+          echo "ADMIN_NAME=dummy" >> .env.test
+          echo "ADMIN_EMAIL=dummy" >> .env.test
+          echo "ADMIN_PASSWORD=dummy" >> .env.test
+
+      - name: Start services with Docker Compose
+        run: docker-compose -f docker-compose.ci.yml up -d --build
+
+      - name: Wait for services to be healthy
+        run: |
+          echo "Waiting for API to be ready..."
+          sleep 15
+
+      - name: Run E2E tests
+        run: docker-compose -f docker-compose.ci.yml exec -T api npm run test:e2e
+
+      - name: Stop services
+        if: always()
+        run: docker-compose -f docker-compose.ci.yml down
+
+  build-and-push-image:
+    runs-on: ubuntu-latest
+    needs: e2e-test
+    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
+    steps:
+      - name: Checkout code
+        uses: actions/checkout@v4
+
+      - name: Log in to Docker Hub
+        uses: docker/login-action@v3
+        with:
+          username: ${{ secrets.DOCKERHUB_USERNAME }}
+          password: ${{ secrets.DOCKERHUB_TOKEN }}
+
+      - name: Build and push Docker image
+        uses: docker/build-push-action@v5
+        with:
+          context: .
+          push: true
+          tags: yourdockerhubusername/flight-booking-api:latest, yourdockerhubusername/flight-booking-api:${{ github.sha }}
+
+  deploy:
+    runs-on: ubuntu-latest
+    needs: build-and-push-image
+    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
+    steps:
+      - name: Placeholder for Deploy
+        run: |
+          echo "Deployment job placeholder"
+          echo "This is where you would add steps to deploy your application."
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..4255018
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,35 @@
+# Stage 1: Build the application
+FROM node:20-alpine AS builder
+
+WORKDIR /usr/src/app
+
+# Copy package.json and package-lock.json
+COPY package*.json ./
+
+# Install dependencies
+RUN npm ci
+
+# Copy application source
+COPY . .
+
+# Build the application
+RUN npm run build
+
+# Prune development dependencies
+RUN npm prune --production
+
+# Stage 2: Create the production image
+FROM node:20-alpine
+
+WORKDIR /usr/src/app
+
+# Create a non-root user
+RUN addgroup -S appgroup && adduser -S appuser -G appgroup
+
+# Copy dependencies and built application from builder stage
+COPY --from=builder /usr/src/app/node_modules ./node_modules
+COPY --from=builder /usr/src/app/dist ./dist
+COPY --from=builder /usr/src/app/package.json ./
+
+USER appuser
+
+EXPOSE 3000
+
+CMD ["node", "dist/main"]
diff --git a/docker-compose.ci.yml b/docker-compose.ci.yml
new file mode 100644
index 0000000..99f365d
--- /dev/null
+++ b/docker-compose.ci.yml
@@ -0,0 +1,24 @@
+version: '3.8'
+
+services:
+  api:
+    build:
+      context: .
+      dockerfile: Dockerfile
+    container_name: test-api
+    ports:
+      - "3001:3000" # Use a different host port to avoid conflicts
+    env_file:
+      - .env.test
+    depends_on:
+      - db
+    command: ["node", "dist/main"]
+
+  db:
+    image: postgres:15-alpine
+    container_name: test-db
+    ports:
+      - "5433:5432" # Use a different host port
+    environment:
+      POSTGRES_USER: ${PG_USER}
+      POSTGRES_PASSWORD: ${PG_PASS}
+      POSTGRES_DB: ${PG_DB_TEST}
diff --git a/docker-compose.yml b/docker-compose.yml
new file mode 100644
index 0000000..096472d
--- /dev/null
+++ b/docker-compose.yml
@@ -0,0 +1,31 @@
+version: '3.8'
+
+services:
+  api:
+    build:
+      context: .
+      dockerfile: Dockerfile
+    container_name: flight-booking-api
+    ports:
+      - "${PORT}:${PORT}"
+    env_file:
+      - .env
+    depends_on:
+      - db
+    volumes:
+      - ./src:/usr/src/app/src
+      - ./test:/usr/src/app/test
+    command: npm run start:dev
+
+  db:
+    image: postgres:15-alpine
+    container_name: flight-booking-db
+    ports:
+      - "${PG_PORT}:${PG_PORT}"
+    environment:
+      POSTGRES_USER: ${PG_USER}
+      POSTGRES_PASSWORD: ${PG_PASS}
+      POSTGRES_DB: ${PG_DB}
+    volumes:
+      - postgres_data:/var/lib/postgresql/data
+
+volumes:
+  postgres_data:
diff --git a/jest.config.js b/jest.config.js
new file mode 100644
index 0000000..0280287
--- /dev/null
+++ b/jest.config.js
@@ -0,0 +1,14 @@
+module.exports = {
+  moduleFileExtensions: ['js', 'json', 'ts'],
+  rootDir: 'src',
+  testRegex: '.*\\.spec\\.ts$',
+  transform: {
+    '^.+\\.(t|j)s$': 'ts-jest',
+  },
+  collectCoverageFrom: ['**/*.(t|j)s'],
+  coverageDirectory: '../coverage',
+  testEnvironment: 'node',
+  moduleNameMapper: {
+    '^src/(.*)$': '<rootDir>/$1',
+  },
+};
diff --git a/package.json b/package.json
index 548c48a..0050519 100644
--- a/package.json
+++ b/package.json
@@ -12,12 +12,12 @@
     "start:debug": "nest start --debug --watch",
     "start:prod": "node dist/main",
     "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
-    "test": "jest",
-    "test:watch": "jest --watch",
-    "test:cov": "jest --coverage",
-    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
+    "test": "jest --config jest.config.js",
+    "test:watch": "jest --watch --config jest.config.js",
+    "test:cov": "jest --coverage --config jest.config.js",
+    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand --config jest.config.js",
     "test:e2e": "jest --config ./test/jest-e2e.json"
   },
   "dependencies": {
@@ -67,22 +67,5 @@
     "ts-node": "^10.9.2",
     "tsconfig-paths": "^4.2.0",
     "typescript": "^5.7.3",
     "typescript-eslint": "^8.20.0"
-  },
-  "jest": {
-    "moduleFileExtensions": [
-      "js",
-      "json",
-      "ts"
-    ],
-    "rootDir": "src",
-    "testRegex": ".*\\.spec\\.ts$",
-    "transform": {
-      "^.+\\.(t|j)s$": "ts-jest"
-    },
-    "collectCoverageFrom": [
-      "**/*.(t|j)s"
-    ],
-    "coverageDirectory": "../coverage",
-    "testEnvironment": "node"
   }
 }
diff --git a/src/api/users/users.service.spec.ts b/src/api/users/users.service.spec.ts
new file mode 100644
index 0000000..3817441
--- /dev/null
+++ b/src/api/users/users.service.spec.ts
@@ -0,0 +1,164 @@
+import { Test, TestingModule } from '@nestjs/testing';
+import { getRepositoryToken } from '@nestjs/typeorm';
+import { Repository } from 'typeorm';
+import { NotFoundException } from '@nestjs/common';
+import { UsersService } from './users.service';
+import { UserEntity } from 'src/core/entities/users.entity';
+import { CreateUserDto } from './dto/create-user.dto';
+import { BcryptEncryption } from 'src/infrastructure/bcrypt';
+import { UpdateUserDto } from './dto/update-user.dto';
+
+// Mock BcryptEncryption
+jest.mock('src/infrastructure/bcrypt');
+
+type MockRepository<T = any> = Partial<Record<keyof Repository<T>, jest.Mock>>;
+const createMockRepository = <T = any>(): MockRepository<T> => ({
+  create: jest.fn(),
+  save: jest.fn(),
+  find: jest.fn(),
+  findOneBy: jest.fn(),
+  delete: jest.fn(),
+});
+
+describe('UsersService', () => {
+  let service: UsersService;
+  let userRepository: MockRepository<UserEntity>;
+
+  beforeEach(async () => {
+    const module: TestingModule = await Test.createTestingModule({
+      providers: [
+        UsersService,
+        {
+          provide: getRepositoryToken(UserEntity),
+          useValue: createMockRepository(),
+        },
+      ],
+    }).compile();
+
+    service = module.get<UsersService>(UsersService);
+    userRepository = module.get(getRepositoryToken(UserEntity));
+  });
+
+  it('should be defined', () => {
+    expect(service).toBeDefined();
+  });
+
+  describe('create', () => {
+    it('should create and save a new user with a hashed password', async () => {
+      const createUserDto: CreateUserDto = {
+        email: 'test@example.com',
+        password: 'password123',
+        firstName: 'Test',
+        lastName: 'User',
+        phoneNumber: '1234567890',
+        passportNumber: 'A123',
+        nationality: 'Testland',
+        dateOfBirth: '2000-01-01',
+      };
+      const hashedPassword = 'hashedPassword';
+      const userEntity = { ...createUserDto, id: 'some-uuid', role: 'passenger' };
+      const savedUser = { ...userEntity, password: hashedPassword };
+      const { password, ...result } = savedUser;
+
+      (BcryptEncryption.encrypt as jest.Mock).mockResolvedValue(hashedPassword);
+      userRepository.create.mockReturnValue(userEntity);
+      userRepository.save.mockResolvedValue(savedUser);
+
+      const createdUser = await service.create(createUserDto);
+
+      expect(BcryptEncryption.encrypt).toHaveBeenCalledWith('password123');
+      expect(userRepository.create).toHaveBeenCalledWith({
+        ...createUserDto,
+        password: hashedPassword,
+      });
+      expect(userRepository.save).toHaveBeenCalledWith(userEntity);
+      expect(createdUser).toEqual(result);
+    });
+  });
+
+  describe('findAll', () => {
+    it('should return an array of users without passwords', async () => {
+      const users = [
+        { id: '1', email: 'test1@example.com', password: 'p1' },
+        { id: '2', email: 'test2@example.com', password: 'p2' },
+      ];
+      userRepository.find.mockResolvedValue(users);
+
+      const result = await service.findAll();
+
+      expect(result).toEqual([
+        { id: '1', email: 'test1@example.com' },
+        { id: '2', email: 'test2@example.com' },
+      ]);
+    });
+  });
+
+  describe('findOne', () => {
+    it('should find and return a user by ID without password', async () => {
+      const user = { id: '1', email: 'test@example.com', password: 'p1' };
+      userRepository.findOneBy.mockResolvedValue(user);
+
+      const result = await service.findOne('1');
+      const { password, ...expected } = user;
+
+      expect(userRepository.findOneBy).toHaveBeenCalledWith({ id: '1' });
+      expect(result).toEqual(expected);
+    });
+
+    it('should throw NotFoundException if user is not found', async () => {
+      userRepository.findOneBy.mockResolvedValue(null);
+      await expect(service.findOne('1')).rejects.toThrow(NotFoundException);
+    });
+  });
+
+  describe('update', () => {
+    it('should update a user and return it without password', async () => {
+      const updateUserDto: UpdateUserDto = { firstName: 'Updated' };
+      const existingUser = { id: '1', firstName: 'Test', password: 'p1' };
+      const updatedUser = { ...existingUser, ...updateUserDto };
+
+      userRepository.findOneBy.mockResolvedValue(existingUser);
+      userRepository.save.mockResolvedValue(updatedUser);
+
+      const result = await service.update('1', updateUserDto);
+      const { password, ...expected } = updatedUser;
+
+      expect(userRepository.findOneBy).toHaveBeenCalledWith({ id: '1' });
+      expect(userRepository.save).toHaveBeenCalledWith(expect.objectContaining({ firstName: 'Updated' }));
+      expect(result).toEqual(expected);
+    });
+
+    it('should hash password if it is provided in update DTO', async () => {
+        const updateUserDto: UpdateUserDto = { password: 'newPassword' };
+        const existingUser = { id: '1', password: 'p1' };
+        const hashedPassword = 'hashedNewPassword';
+
+        (BcryptEncryption.encrypt as jest.Mock).mockResolvedValue(hashedPassword);
+        userRepository.findOneBy.mockResolvedValue(existingUser);
+        userRepository.save.mockResolvedValue({ ...existingUser, password: hashedPassword });
+
+        await service.update('1', updateUserDto);
+
+        expect(BcryptEncryption.encrypt).toHaveBeenCalledWith('newPassword');
+        expect(userRepository.save).toHaveBeenCalledWith(expect.objectContaining({ password: hashedPassword }));
+    });
+
+    it('should throw NotFoundException if user to update is not found', async () => {
+      userRepository.findOneBy.mockResolvedValue(null);
+      await expect(service.update('1', {})).rejects.toThrow(NotFoundException);
+    });
+  });
+
+  describe('remove', () => {
+    it('should remove a user and return a success message', async () => {
+      const user = { id: '1' };
+      userRepository.findOneBy.mockResolvedValue(user);
+      userRepository.delete.mockResolvedValue({ affected: 1 });
+
+      const result = await service.remove('1');
+
+      expect(userRepository.findOneBy).toHaveBeenCalledWith({ id: '1' });
+      expect(userRepository.delete).toHaveBeenCalledWith('1');
+      expect(result).toEqual({ message: `User with ID "1" has been successfully deleted.` });
+    });
+
+    it('should throw NotFoundException if user to remove is not found', async () => {
+      userRepository.findOneBy.mockResolvedValue(null);
+      await expect(service.remove('1')).rejects.toThrow(NotFoundException);
+    });
+  });
+});
diff --git a/test/app.e2e-spec.ts b/test/app.e2e-spec.ts
index 8933b2e..2899450 100644
--- a/test/app.e2e-spec.ts
+++ b/test/app.e2e-spec.ts
@@ -2,7 +2,7 @@
 import { INestApplication } from '@nestjs/common';
 import * as request from 'supertest';
 import { App } from 'supertest/types';
-import { AppModule } from './../src/app.module';
+import { AppModule } from 'src/api/app.module';
 
 describe('AppController (e2e)', () => {
   let app: INestApplication<App>;
@@ -16,10 +16,11 @@
     await app.init();
   });
 
-  it('/ (GET)', () => {
+  // The default route is not defined, this test would fail.
+  // A health check endpoint is a good alternative.
+  it('/health (GET)', () => {
     return request(app.getHttpServer())
-      .get('/')
-      .expect(200)
-      .expect('Hello World!');
+      .get('/health')
+      .expect(200);
   });
 });
diff --git a/test/jest-e2e.json b/test/jest-e2e.json
index 3f41113..678881d 100644
--- a/test/jest-e2e.json
+++ b/test/jest-e2e.json
@@ -1,9 +1,13 @@
 {
   "moduleFileExtensions": ["js", "json", "ts"],
-  "rootDir": ".",
+  "rootDir": "..",
   "testEnvironment": "node",
   "testRegex": ".e2e-spec.ts$",
   "transform": {
     "^.+\\.(t|j)s$": "ts-jest"
+  },
+  "moduleNameMapper": {
+    "^src/(.*)$": "<rootDir>/src/$1"
   }
 }
diff --git a/test/users.e2e-spec.ts b/test/users.e2e-spec.ts
new file mode 100644
index 0000000..91a5611
--- /dev/null
+++ b/test/users.e2e-spec.ts
@@ -0,0 +1,77 @@
+import { Test, TestingModule } from '@nestjs/testing';
+import { INestApplication, ValidationPipe } from '@nestjs/common';
+import * as request from 'supertest';
+import { AppModule } from 'src/api/app.module';
+import { getRepositoryToken } from '@nestjs/typeorm';
+import { UserEntity } from 'src/core/entities/users.entity';
+import { Repository } from 'typeorm';
+
+describe('UsersController (e2e)', () => {
+  let app: INestApplication;
+  let userRepository: Repository<UserEntity>;
+  let createdUserId: string;
+
+  beforeAll(async () => {
+    const moduleFixture: TestingModule = await Test.createTestingModule({
+      imports: [AppModule],
+    }).compile();
+
+    app = moduleFixture.createNestApplication();
+    app.useGlobalPipes(
+      new ValidationPipe({
+        whitelist: true,
+        forbidNonWhitelisted: true,
+        transform: true,
+      }),
+    );
+    await app.init();
+
+    userRepository = moduleFixture.get<Repository<UserEntity>>(
+      getRepositoryToken(UserEntity),
+    );
+  });
+
+  beforeEach(async () => {
+    // Clean up before each test
+    await userRepository.delete({});
+  });
+
+  afterAll(async () => {
+    await app.close();
+  });
+
+  describe('/users (POST)', () => {
+    const createUserDto = {
+      email: 'e2e.test@example.com',
+      password: 'password123',
+      firstName: 'E2E',
+      lastName: 'Test',
+      phoneNumber: '1234567890',
+      passportNumber: 'E2E123',
+      nationality: 'Testland',
+      dateOfBirth: '2000-01-01',
+    };
+
+    it('should create a new user and return it without the password', async () => {
+      const res = await request(app.getHttpServer())
+        .post('/users')
+        .send(createUserDto)
+        .expect(201);
+
+      expect(res.body).toBeDefined();
+      expect(res.body.email).toEqual(createUserDto.email);
+      expect(res.body.password).toBeUndefined();
+      expect(res.body.id).toBeDefined();
+      createdUserId = res.body.id;
+
+      // Verify user exists in the database
+      const userInDb = await userRepository.findOneBy({ id: createdUserId });
+      expect(userInDb).toBeDefined();
+      expect(userInDb.email).toEqual(createUserDto.email);
+    });
+
+    it('should fail with validation error for bad request', () => {
+      return request(app.getHttpServer())
+        .post('/users')
+        .send({ email: 'not-an-email', password: 'short' })
+        .expect(400);
+    });
+  });
+});
```